 : Hi DUP $5 $48 paint_char $6 $69 paint_char ;

\ I can haz line comments?

: H@ HERE @ ;
: kj DUP H@ SWAP - SWAP ! ;
: IF IMMEDIATE ' 0BRANCH , H@ $0 , ;
: THEN IMMEDIATE kj ;
: ELSE IMMEDIATE ' BRANCH , H@ $0 , SWAP kj ;
: BEGIN IMMEDIATE H@ ;
: UNTIL IMMEDIATE ' 0BRANCH , H@ - , ;

: =1- = IF 1- THEN ;
: 0? DUP $0 = ;

: ( IMMEDIATE
	$1  \ Count the number of '(' encountered.
	BEGIN
		KEY        \ Consume a character.
		DUP $28 =	 \ '(' is 0x28
		IF         \ For opening parens
			DROP     \ drop the character
			1+       \ increment the count.
		ELSE
			$29      \ ')' is 0x29
			=1-      \ For closing parens decrement the count.
		THEN
		0?       \ Have we found the final closing parenthesis
	UNTIL    \ Then we are finished.
	DROP     \ Drop the (zero'd) counter.
;


( I can haz (nested) parentheses comments! )

$2 Hi
$3 Hi
$4 Hi


: CONSTANT WORD CREATE DOCOL , ' LIT , , ' EXIT ,	;
: ALLOT H@ SWAP HERE +! ;
: CELLS $4 * ;
: VARIABLE $1 CELLS ALLOT CONSTANT ;


$e7f00 CONSTANT DISPLAY_START
$18000 CONSTANT DISPLAY_LENGTH  ( 1024 * 768 / 8 = 98304 )


( Let's implement a Joy-in-Forth

We're going to use the format specified in the book:
https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-33.html#%_sec_5.3.1

So we have a "vector" of heads and another "vector" of tails, which
contain tagged pointers.  For now I think we want:

- Numbers, both inline and indirect
- List cells
  - "the empty list is denoted by the pointer e0"
- Symbols or Codewords
- ?

The first two decisions are where to put the lists and how long to make
them.  We have plenty of room, and the data and return stacks can be
moved, so let's just use ALLOT.  I think to start out 1024 cells should
be fine.
)

$400 CELLS DUP
ALLOT CONSTANT HEADS
ALLOT CONSTANT TAILS

( From the book: "We presume that there is a special register,
free, that always holds a pair pointer containing the next available
index, and that we can increment the index part of that pointer to find
the next free location." )

VARIABLE free

$0 free !  \ Set the free pointer.

( For tagged pointers I'm going to try putting the tag in the upper, say,
four bits, and let the rest be the offset or numeric value or whatever.
For list cells let the four bits be all zeros.  See how that works out.

So how do we create these things?  Normally there would be a text-to-Joy
function but here there isn't enough infrastructure to do that yet.

We can put a new, empty list onto the Forth stack by simply pushing zero.
)

$0

( Now how would we put a number onto that Joy stack from Forth?  First,
convert the number to a Joy stack tagged pointer.  Let the MSB indicate
that a value is a number.  So negtive numbers are already fine, and we
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                           no, they are not. what was I smoking?
just have to set the MSB of positive numbers, eh?
)

: nf2j DUP $0 >= IF $80000000 + THEN ;  / number Forth to Joy

$123 nf2j

( So now we have a pointer to the nil list and a number "pointer" on the
stack, How to cons them together?

    : CONS ( tail head -- list ) 
        / we are going to want to do 
           head HEADS free @ + !
           tail TAILS free @ + !
           free @  / Put the "pointer" to the result list on the stack.
           free $4 +!
    ;

While it would be neat to figure out a way to do all this and only fetch
free once, it's easier to do this:
)

: f@+! free @ + ! ;  / Add free pointer to vector and store a value there.
: f@4! free DUP @ SWAP $4 +! ;  / Leave new list on stack, point to next free cell.

( In Joy you could do:

free DUP @ DUP $4 + [swap] dip !
free free@ feee@+4  [swap] dip !
free@ free free@+4 !

-or-

free DUP @ DUP   [$4 + !] dip
free free@ free@ [$4 + !] dip
free free@ $4 + ! free@

)

: CONS HEADS f@+! TAILS f@+! f@4! ;

TRAP

( Naming sucks (for me) but I feel this is a "Forthic"? "Forthionic"? way
to do things.

This is inefficient, but we will figure out ways to more easily specify
more efficient forms as we get into Joy and higher order combinators.

So:
)

CONS

( Should create a cons cell in the vectors and leave its pointer on the
stack, eh?  You could then do:
)
    $1 nf2j CONS $2 nf2j CONS $3 nf2j CONS

( To add three more numbers to the Joy stack.

So where do we go from here?  We want to write a version of cons that
performs Joy cons as opposed to the above Forth cons.  What I mean is,
the function we just defined takes a list and an item from the Forth
stack, we want a function that takes a list and an item from the Joy
stack.

Assume the item on the top of the Forth stack is a ("pointer" to a) Joy
list.  We can put a new blank list and an int onto it with:

    $0 CONS $23 nf2j CONS

Here's what the cons cell vectors hold:

    HEADS TAILS
      e0   pX   <- address N
      23   pN   <- N+1
                <- free

With pN+1 on the Forth stack.  Now "cons" (the Joy version) will make a
new cons cell out of those parts and then update the Joy stack:

    HEADS TAILS
      e0   pX   <- address N
      23   pN   <- N+1
      23   e0   <- N+2
    pN+2   pX   <- N+3 on Forth stack as new Joy stack "pointer"
                <- free

Leaving pN+3 on the Forth stack.

Note that the vector cells at N and N+1 are now garbage, and two new
cells are allocated, one represents "[23]" and the other is the new head
of the Joy stack.

So how do we do this?

We need to get two items from the Joy stack, so we need UNCONS

    : UNCONS ( list -- tail head )
        DUP       \ list list
        TAIL + @  \ list tail
        SWAP      \ tail list
        HEAD + @  \ tail head
    ;

(Maybe that should be  ( list -- head tail ) ?)

       [23 [] ...] UNCONS SWAP UNCONS
    ------------------------------------
                23 [...] []

Now we want to make [23] and then CONS it onto the Joy stack.  We need a
little stck chatter to get it to: "[...] [] 23", ROLL or ROLL ROLL
(I have to look up how Forth's ROLL works), then it's just a matter
of CONS CONS:

    [...] [] 23 CONS CONS
    [...] [23]       CONS
    [[23] ...]

    QED

: cons UNCONS SWAP UNCONS ROLL CONS CONS ;

    [23 [] ...] UNCONS SWAP UNCONS ROLL CONS CONS
    [[] ...] 23        SWAP UNCONS ROLL CONS CONS
    23 [[] ...]             UNCONS ROLL CONS CONS
    23 [...] []                    ROLL CONS CONS
    [...] [] 23                         CONS CONS
    [...] [23]                               CONS
    [[23] ...]

Ta-da!

We have two UNCONS's and two CONS's to match up with the two (really
four) cells of garbage and two (really four) new cells we expected.

And that's how it goes.  The math/logic/comparison words are
straightforward (and uninteresting), and the stack chatter and list
manipulation are simple patterns of CONS/UNCONS and (Forth) stack chatter
("froth"?)  Even the combinators are fairly dull.

The Joy interpreter...

We have a stack, we need to model the Joy expression.  We'll use a stack
of stacks so that prepending new expressions to the current expression is
just cons'ing a stack onto a stack.  The interpreter pops from the
current expression stack until it's empty then it discards it and keeps
going with the next expression stack.  For efficiency we'll use a
register and machine stack rather than linked lists for this.








)


pai

