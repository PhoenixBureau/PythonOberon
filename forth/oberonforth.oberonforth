 : Hi DUP $5 $48 paint_char $6 $69 paint_char ;

\ I can haz line comments?

: H@ HERE @ ;
: kj DUP H@ SWAP - SWAP ! ;
: IF IMMEDIATE ' 0BRANCH , H@ $0 , ;
: THEN IMMEDIATE kj ;
: ELSE IMMEDIATE ' BRANCH , H@ $0 , SWAP kj ;
: BEGIN IMMEDIATE H@ ;
: UNTIL IMMEDIATE ' 0BRANCH , H@ - , ;

: =1- = IF 1- THEN ;
: 0? DUP $0 = ;

: ( IMMEDIATE
	$1  \ Count the number of '(' encountered.
	BEGIN
		KEY        \ Consume a character.
		DUP $28 =	 \ '(' is 0x28
		IF         \ For opening parens
			DROP     \ drop the character
			1+       \ increment the count.
		ELSE
			$29      \ ')' is 0x29
			=1-      \ For closing parens decrement the count.
		THEN
		0?       \ Have we found the final closing parenthesis
	UNTIL    \ Then we are finished.
	DROP     \ Drop the (zero'd) counter.
;

( I can haz (nested) parentheses comments! )

$2 Hi
$3 Hi
$4 Hi


: CONSTANT WORD CREATE DOCOL , ' LIT , , ' EXIT ,	;
: ALLOT H@ SWAP HERE +! ;
: CELLS $4 * ;
: VARIABLE $1 CELLS ALLOT CONSTANT ;


$e7f00 CONSTANT DISPLAY_START
$18000 CONSTANT DISPLAY_LENGTH  ( 1024 * 768 / 8 = 98304 )


( Let's implement a Joy-in-Forth

We're going to use the format specified in the book:
https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-33.html#%_sec_5.3.1

So we have a "vector" of heads and another "vector" of tails, which
contain tagged pointers.  For now I think we want:

- Numbers, both inline and indirect
- List cells
  - "the empty list is denoted by the pointer e0"
- Symbols or Codewords
- ?

The first two decisions are where to put the lists and how long to make
them.  We have plenty of room, and the data and return stacks can be
moved, so let's just use ALLOT.  I think to start out 1024 cells should
be fine.

)

$400 CELLS DUP
ALLOT CONSTANT HEADS
ALLOT CONSTANT TAILS


( From the book: "We presume that there is a special register,
free, that always holds a pair pointer containing the next available
index, and that we can increment the index part of that pointer to find
the next free location." )

VARIABLE free

$0 free !  \ Set the free pointer.

( For tagged pointers I'm going to try putting the tag in the upper, say,
four bits, and let the rest be the offset or numeric value or whatever.
For list cells let the four bits be all zeros.  See how that works out.

So how do we create these things?  Normally there would be a text-to-Joy
function but here there isn't enough infrastructure to do that yet.

We can put a new, empty list onto the Forth stack by simply pushing zero.

    $0

Now how would we put a number onto that Joy stack from Forth?  First,
convert the number to a Joy stack tagged pointer.  Let the MSB indicate
that a value is a number.  So negtive numbers are already fine, and we
just have to set the MSB of positive numbers, eh?

    : nf2j DUP $0 >= IF $80000000 + THEN ;  / number Forth to Joy

So now we have a pointer to a cons cell and a number "pointer" on the
stack, How to cons them together?

    : CONS ( tail head -- list ) 
        / we are going to want to do 
           head HEADS free @ + !
           tail TAILS free @ + !
           free @  / Keep the result list on the stack.
           free $4 +!
    ;

While it would be neat to figure out a way to do all this and only fetch
free once, it's easier to do this:

    : f@+! free @ + ! ;  / Add free pointer to vector and store a value there.
    : f@4! free @ free $4 +! ;  / Leave new list on stack, point to next free cell.

    : CONS HEADS f@+! TAILS f@+! f@4! ;

Eh?  And I bet there's a nice way to write f@4! too.
Naming sucks (for me) but I feel this is a "Forthic"? "Forthionic"? way
to do things.

This is inefficient, but we will figure out ways to more easily specify
more efficient forms as we get into Joy and higher order combinators.

So:

    $0 $123 nf2j CONS

Should create a cons cell in the vectors and leave its pointer on the
stack, eh?  You could then do:

    $1 nf2j CONS $2 nf2j CONS $3 nf2j CONS

To add three more numbers to the Joy stack.

)

pai












